
#include "Seamless/TemplateCompiler/TemplateCompiler.hpp"

#include "Seamless/TemplateCompiler/Chunks/UnparsedChunk.hpp"
#include "Seamless/TemplateCompiler/Chunks/ResolvedChunk.hpp"
#include "Seamless/TemplateCompiler/Chunks/StringLiteralChunk.hpp"

#include "Seamless/String.hpp"
#include "Seamless/Error.hpp"

#include "Seamless/Filesystem.hpp"

#include <sstream>

cmls::TemplateCompiler::TemplateCompiler(std::string const &root, TemplateCompilerSettings settings)
{
  m_root = cmls::Directory(root).fullPath();
  m_settings = settings;

  // Always have seamless as an import
  m_imports.push_back("Seamless");
}

cmls::TemplateCompiler::~TemplateCompiler()
{
  std::set<CompilationChunk*> tmp;
  tmp.swap(m_chunkCache);

  for (auto c : tmp)
  {
    delete c;
  }
}

bool cmls::TemplateCompiler::compile(std::string const &inputPath, std::string const &outputPath)
{
  auto input = cmls::stringFromFile(inputPath);
  if (!input.has_value())
  {
    LogError("Failed to read input file %s", inputPath.c_str());
    return false;
  }

  auto modules = importedModules();

  std::string output = generateCppUnit(compileString(input.value()));


  cmls::File outputFile(outputPath);
  cmls::Directory outputDirectory(outputFile.path());
  if (!outputDirectory.exist() && !outputDirectory.create())
  {
    LogError("Failed to create output directory %s", outputDirectory.fullPath().c_str());
    return false;
  }

  std::ofstream out(outputPath);
  if (!out.is_open())

  {
    LogError("Failed to write output file %s", outputPath.c_str());
    return false;
  }

  out << output;
  out.close();

  LogNotice("Compiled %s -> %s", inputPath.c_str(), outputPath.c_str());

  return true;
}

std::string cmls::TemplateCompiler::generateCppUnit(std::string const &sourceCpp)
{
  std::stringstream output;

  output << "// Generated by CMLS compiler context\n";
  output << "\n";

  output << "// Setup view includes\n";
  for (auto i : m_includes)
  {
    output << "#include " << i << "\n";
  }
  output << "\n";

  output << "// Implicit includes from module imports\n";
  for (auto m : importedModules())
  {
    for (auto i : m.includes())
    {
      output << "#include " << i << "\n";
    }
  }
  output << "\n";
  
  output << "// Main entry point for this view\n";
  output << "extern \"C\" __declspec(dllexport) void cmls_main(cmls::Request const &request, cmls::Response &response, cmls::ViewParameterList &parameters)\n";
  output << "{\n";

  output << "  // Setup parameters\n";
  for (auto p : m_parameters)
  {
    output << "  auto " << p.first << "_optional = parameters.get<" << p.second << ">(\"" << p.first << "\");\n";
    output << "  if(!" << p.first << "_optional)\n";
    output << "  {\n";
    output << "    LogError(\"Parameter " << p.first << " either doesn't exist or is not a " << p.second << "\");\n";
    output << "    return;\n";
    output << "  }\n";
    output << "  \n";
    output << "  auto " << p.first << " = " << p.first << "_optional.value();\n";
    output << "  \n";
  }

  output << "  \n";
  output << "  // Main view logic\n";
  output << "  {\n";
  output << sourceCpp << "\n";
  output << "  }\n";
  
  output << "}\n";

  return output.str();
}

std::string cmls::TemplateCompiler::compileString(std::string const &source)
{
  // First, create a big unparsed chunk of the source string and resolve it
  auto chunkSet = resolveChunk(new cmls::UnparsedChunk(this, source));

  // Then, run optimizations on the returned chunkset
  if (m_settings.optimize)
  {
    chunkSet = optimizeChunkSet(chunkSet);
  }

  // Then, finalize the optimized chunkset
  return finalizeChunkSet(chunkSet);
}

std::vector<cmls::CompilationChunk*> cmls::TemplateCompiler::resolveChunk(cmls::CompilationChunk *chunk)
{
  std::vector<cmls::CompilationChunk*> chunkSet;
  chunkSet.push_back(chunk);

  size_t unresolvedChunks = 1;
  while (unresolvedChunks > 0)
  {
    unresolvedChunks = 0;
    std::vector<cmls::CompilationChunk*> newChunks;

    for (auto chunk : chunkSet)
    {
      auto newUnresolvedChunks = chunk->resolveChunk();

      if (newUnresolvedChunks.size() > 0)
      {
        // We resolved this chunk into new chunks, which means we have new unresolved chunks
        newChunks.insert(newChunks.end(), newUnresolvedChunks.begin(), newUnresolvedChunks.end());
        unresolvedChunks += newUnresolvedChunks.size();
      }
      else
      {
        // This is resolved
        auto *asResolved = dynamic_cast<cmls::ResolvedChunk*>(chunk);
        if (!asResolved)
        {
          unresolvedChunks++;
        }

        newChunks.push_back(chunk);
      }
    }

    newChunks.swap(chunkSet);
  }

  return chunkSet;
}

std::vector<cmls::CompilationChunk*> cmls::TemplateCompiler::optimizeChunkSet(std::vector<cmls::CompilationChunk*> const &chunkSet)
{
  // Only one optimization so far; Merge string literals to optimize runtime performance
  std::vector<cmls::CompilationChunk*> returner;

  cmls::StringLiteralChunk *tempLiteral = nullptr;

  for (auto chunk : chunkSet)
  {
    cmls::StringLiteralChunk *asLiteral = dynamic_cast<cmls::StringLiteralChunk*>(chunk);
    if (asLiteral)
    {
      if (!tempLiteral)
      {
        tempLiteral = new cmls::StringLiteralChunk(this, asLiteral->string());
      }
      else
      {
        tempLiteral->append(asLiteral->string());
      }
    }
    else
    {
      if (tempLiteral)
      {
        returner.push_back(tempLiteral);
        tempLiteral = nullptr;
      }

      returner.push_back(chunk);
    }
  }

  if (tempLiteral)
  {
    returner.push_back(tempLiteral);
    tempLiteral = nullptr;
  }

  return returner;
}

std::string cmls::TemplateCompiler::finalizeChunkSet(std::vector<cmls::CompilationChunk*> const &chunkSet)
{
  std::string output;
  for (auto chunk : chunkSet)
  {
    ResolvedChunk *asResolved = dynamic_cast<ResolvedChunk*>(chunk);
    if (!asResolved)
    {
      continue;
    }

    output += asResolved->finalizeChunk();
  }

  return output;
}

std::string cmls::TemplateCompiler::finalizeVirtual(std::string const &variableName)
{
  std::string cleanName = cmls::trim(variableName);

  auto v = m_virtualCache.find(cleanName);
  if (v == m_virtualCache.end())
  {
    return "";
  }

  std::string returner;
  for (auto s : v->second)
  {
    returner += compileString(s);
  }

  return returner;
}

void cmls::TemplateCompiler::implementVirtual(std::string const &variableName, std::string const &unparsedSource)
{
  std::string cleanName = cmls::trim(variableName);

  m_virtualCache[cleanName] = { unparsedSource };
}


void cmls::TemplateCompiler::pushVirtual(std::string const &variableName, std::string const &unparsedSource)
{
  std::string cleanName = cmls::trim(variableName);

  auto v = m_virtualCache.find(variableName);
  if (v == m_virtualCache.end())
  {
    m_virtualCache[cleanName] = { unparsedSource };
  }
  else
  {
    v->second.push_back(unparsedSource);
  }
}

void cmls::TemplateCompiler::registerChunk(CompilationChunk *chunk)
{
  m_chunkCache.insert(chunk);
}

void cmls::TemplateCompiler::unregisterChunk(CompilationChunk *chunk)
{
  m_chunkCache.erase(chunk);
}

void cmls::TemplateCompiler::addInclude(std::string const &includePathWithQuotesOrTags)
{
  auto finder = std::find(m_includes.begin(), m_includes.end(), includePathWithQuotesOrTags);
  if (finder != m_includes.end())
  {
    return;
  }

  m_includes.push_back(includePathWithQuotesOrTags);
}

void cmls::TemplateCompiler::addImport(std::string const &moduleName)
{
  auto finder = std::find(m_imports.begin(), m_imports.end(), moduleName);
  if (finder != m_imports.end())
  {
    return;
  }

  m_imports.push_back(moduleName);
}

void cmls::TemplateCompiler::addParameter(std::string const &typeName, std::string const &parameterName)
{
  auto v = m_parameters.find(parameterName);
  if (v != m_parameters.end() && v->second != typeName)
  {
    LogError("Tried to add parameter %s that already existed of different type. Old: %s, New: %s", parameterName.c_str(), v->second.c_str(), typeName.c_str());
  }

  m_parameters[parameterName] = typeName;
}

std::vector<cmls::Module> cmls::TemplateCompiler::importedModules()
{
  auto allModules = cmls::Module::allModules(m_root);
  std::vector<cmls::Module> returner;
  for (auto i : m_imports)
  {
    auto m = allModules.find(i);
    if (m == allModules.end())
    {
      LogError("Imported module not found (%s)", i.c_str());
      continue;
    }

    returner.push_back(m->second);
  }

  return returner;
}

std::string const& cmls::TemplateCompiler::root() const
{
  return m_root;
}
